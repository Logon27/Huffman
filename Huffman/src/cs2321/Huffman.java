package cs2321;

import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import net.datastructures.*;

/*
 * Author Logan Zehm and Jacob Abeyta
 * Assignment 5
 * Huffman Encoding / Decoding
 */

/*
 * The format of the compressed file includes 3 continuously parts:
 *  1. prefix tree in bit stream
 *  2. length of the original file using 4 bytes
 *  3. data coded with Huffman coding. 
 * 
 * Encoding prefix tree bit stream: 
 *   if the node is external, output 0, followed by the letter
 *   if the node is internal, output 1, followed by 
 *  		the bit stream of left subtree, then the bit stream of right subtree. 
 */
public class Huffman {
	
    LinkedBinaryTree<Character> buildTree;
    HeapPQ<Integer, LinkedBinaryTree<Character>> PQ = new HeapPQ<>();
    String[] codeTable = new String[256];
    BitBufferReader buffer;
    int characterCount;
	int[] freq = new int[256];

	/**
	 * Compress file using Huffman code. 
	 * @param inputFile  The original data file
	 * @param outputFile  The compressed data file that should be generated. 
	 * @return the length of the data encoded with Huffman Code, don't include data for the prefix tree and length of the original file. 
	 */
    public int compress(String inputFile, String outputFile) {

    	//create new code table and bit buffer reader
		codeTable = new String[256];
		buffer = new BitBufferReader(outputFile);
		
		//calculate character count for input file.
		characterCount = characterCount(inputFile);
		
		char[] inputArray = new char[characterCount];

		try {
			//loop through every character in the file and add it to a char array
			FileReader fileReader = new FileReader(inputFile);
			int count = 0;
			while (fileReader.ready()) {
				inputArray[count] = (char) fileReader.read();
				count++;
			}
			fileReader.close();
		} catch (IOException e) {
			System.out.println("IOException when reading or closing file.");
		}
		
		//input the char array to build our prefix tree
		LinkedBinaryTree<Character> tree = buildPrefixTree(inputArray);
		//build call from notes to build the code table
		buildCodeTable(tree.root(), "");

		//write the tree to the file
		for (Position<Character> node : tree.positions()) {

			if (tree.isInternal(node)) {
				buffer.writeBit(1);
			}
			if (tree.isExternal(node)) {
				buffer.writeBit(0);
				//cast the node element to ascii
				int ascii = (int) node.getElement();
				//mask and bit writing from study session
				int mask = 1 << 7;
				//convert ascii value to byte of data and write to byte buffer
				for (int i = 0; i < 8; i++) {
					int bit = ascii & mask;
					
					if (bit == mask) {
						buffer.writeBit(1);
					} else {
						buffer.writeBit(0);
					}
					ascii = ascii << 1;
				}
			}
		}

		//Make a binary string of the value of our character count in 32 bits.
		String fileSize = Long.toBinaryString(Integer.toUnsignedLong(characterCount) | 0x100000000L).substring(1);

		//write the filesize to our byte buffer
		for(char c : fileSize.toCharArray()) {
			if(c == '1') {
				buffer.writeBit(1);
			} else {
				buffer.writeBit(0);
			}
		}

		//create huffman int to count the length of our huffman code;
		int finalHuff = 0;
		//write the huffmanCode to the bit buffer
		for(char c : inputArray) {
			//pull huffman code from codetable then write to the byte buffer bit by bit
			String huffCode = codeTable[(int) c];
			//increment finalHuff count
			finalHuff += huffCode.length();
			for(char k : huffCode.toCharArray()) {
				if (k == '1') {
					buffer.writeBit(1);
				} else {
					buffer.writeBit(0);
				}
			}
		}
		
		//add padding if the final byte isnt filled completely
		while (buffer.getWriteCount() != 0) {
			buffer.writeBit(0);
		}

		//write the finalized bit buffer to the file.
		buffer.writeToFile();

		//return the total size of the huffman code
		return finalHuff;
    }
    
	/**
	 * Decode the compressed data file back to the original data file. 
	 * @param inputFile : the compressed file
	 * @param outputFile : the file that should be generated by the decode function using ascii code. 
	 */
    public void decode(String inputFile, String outputFile) {

    	//create new code table and bit buffer reader
        codeTable = new String[256];
    	buffer = new BitBufferReader(outputFile);

    	//create a byte array for our incoming bytes
        byte[] fileBytes = null;

        try {
        	//read all bytes from the file to the byte array
        	Path path = Paths.get(inputFile);
        	fileBytes = Files.readAllBytes(path);
        } catch (Exception e) {
            System.out.println("Unable to read file");
        }

        ArrayList<String> inputBytes = new ArrayList<String>();

        for (byte b : fileBytes) {
        	//convert all bytes from the byte array to binarystrings and add to arraylist.
        	inputBytes.addLast(String.format("%8s", Integer.toBinaryString(b & 0xFF)).replace(' ', '0'));
        }

        //grab the individual bits from the byte arraylist and add them to our byte buffer input array
        for (String s : inputBytes) {
            for (int i = 0; i < 8; i++) {
                buffer.getInputBinaryArray().addLast(Integer.parseInt(String.valueOf(s.charAt(i))));
            }
        }

        //Create the prefix tree from the first set of data
        LinkedBinaryTree<Character> huffmanTree = readPrefixTree();

        //convert the next 4 file size bytes to binary strings and concat
        String fileSizeString = "";
        for(int i = 0; i < 4; i++) {
        	fileSizeString += String.format("%8s", Integer.toBinaryString(buffer.readNextByte())).replace(' ', '0');
        }

        //parse the binary string to an integer. 
        int fileSize = Integer.parseInt(fileSizeString, 2);

        //decode all the characters with the huffman tree and add to the decoded string.
        try {
        	//open our filewriter and write the decoded string to the output file.
            FileWriter fileWriter = new FileWriter(outputFile);
	        for (int i = 0; i < fileSize; i++) {
	            Position<Character> V = huffmanTree.root();
	            while (huffmanTree.isInternal(V)) {
	            	//read the next bit and traverse left if bit is 0 and right if 1.
	                int bit = buffer.getNextBit();
	                if (bit == 0) {
	                    V = huffmanTree.left(V);
	                } else {
	                    V = huffmanTree.right(V);
	                }
	            }
	            //concat our character at the given element to the end of our decoded string if the node is external.
	            fileWriter.write(V.getElement());
	        }
            fileWriter.close();
        } catch (Exception e) {
            System.out.println("Unable to close file writer");
        }

    }

    //build our prefix tree given our array of characters
    public LinkedBinaryTree<Character> buildPrefixTree(char[] A) {
        
    	//calculate freq array
		for (int i = 0; i < A.length; i++) {
			freq[A[i]]++;
		}

        for (char i = 0; i < 256; i++) {
            if (freq[i] > 0) {
            	buildTree = new LinkedBinaryTree<>();
            	buildTree.addRoot(i);
                PQ.insert(freq[i], buildTree);
            }
        }

        while (PQ.size() > 1) {
            Entry<Integer, LinkedBinaryTree<Character>> e1 = PQ.removeMin();
            Entry<Integer, LinkedBinaryTree<Character>> e2 = PQ.removeMin();
            int combinedFreq = e2.getKey() + e1.getKey();
            buildTree = new LinkedBinaryTree<Character>();
            buildTree.addRoot((char) 0);
            buildTree.attach(buildTree.root(), e1.getValue(), e2.getValue());
            PQ.insert(combinedFreq, buildTree);
        }
        
        return PQ.min().getValue();
    }

    //build our code table by traversing the tree if the position is external
    public void buildCodeTable(Position<Character> V, String code) {
        if (buildTree.isExternal(V)) {
        	codeTable[V.getElement()] = code;
        } else {
            buildCodeTable(buildTree.left(V), code + "0");
            buildCodeTable(buildTree.right(V), code + "1");
        }

    }

    //create our prefix tree from the first set of bits in the compressed file
    public LinkedBinaryTree<Character> readPrefixTree() {
    	
        int b = buffer.getNextBit();
        //if the bit is a 0 then add the next byte as a character to the tree root.
        if (b == 0) {
            LinkedBinaryTree<Character> t = new LinkedBinaryTree<>();
            char l = (char) buffer.readNextByte();
            t.addRoot(l);
            return t;
        } else {
        	//else add a blank internal node and recursively call the prefix tree.
            LinkedBinaryTree<Character> t1 = readPrefixTree();
            LinkedBinaryTree<Character> t2 = readPrefixTree();
            LinkedBinaryTree<Character> t = new LinkedBinaryTree<>();
            t.addRoot((char) 0);
            t.attach(t.root(), t1, t2);
            return t;
        }

    }
    
    //calculate the character count of the input file
    public int characterCount(String inputFile) {
		int count = 0;
		try {
			FileReader fileReader = new FileReader(inputFile);
			//while there are more characters to be read increment the count.
			while (fileReader.read() != -1) {
				count++;
			}
			fileReader.close();
		} catch (IOException e) {
			System.out.println("IOException when reading or closing file.");
		}
		return count;
    }
    
    public static void main(String[] args) {
		Huffman huffman = new Huffman();
		int length;
		
		// db.txt has only two letters "ab". The length with Huffman coding should be 2. 
		length = huffman.compress("ab.txt", "ab.txt.huffman");
		System.out.println("length is" + length);
		
		// decode your newly created compress file. The generated file "ab.txt.decoded" should have same content as "ab.txt"
		huffman.decode("ab.txt.huffman", "ab.txt.decoded");
		
		
		// decode the previous correctly compressed file by instructor.  The generated file "ab.txt.decoded" should have content as "ab.txt"
		huffman.decode("ab.txt.compressed", "ab.txt.decoded");
    }
	
}
